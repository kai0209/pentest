package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"math/rand"
	"mime/multipart"
	"net/http"
	"os"
	"strings"
	"time"
	"path/filepath"
	
	"github.com/cheggaaa/pb/v3"
)

const endpoint string = "https://localhost/"
const connector string = "fckeditor/editor/filemanager/connectors/php/connector.php?Type=Media&CurrentFolder="
const newFolder string = "&Command=CreateFolder&NewFolderName="
const upload string = "&Command=FileUpload"
const handle string = "userfiles/media/"
const barTemplate string = `{{ bar . "[" "O" (cycle . "." "o" "O" "0" ) " " "]"}} {{percent .}} {{string . "statement" | green}}`
const threads int64 = 8

var uri string
var key string

type Meta struct {
	Name   string `json:"name"`
	Chunks int64  `json:"chunks"`
}

func uploadChunk(Chunk []byte, i int64, bar *pb.ProgressBar, wait chan<- string) {
	defer bar.Increment()
	client := &http.Client{}
	b := &bytes.Buffer{}
	w := multipart.NewWriter(b)
	req := &http.Request{}
	r := &http.Response{}
	var p io.Writer
	var err error
	
	var UploadFileName string
	if i == -1 {
		UploadFileName = fmt.Sprintf("%s.gif", key)
	} else {
		UploadFileName = fmt.Sprintf("%s_%d.gif", key, i)
	}

	if p, err = w.CreateFormFile("NewFile", UploadFileName); err != nil {
		log.Fatalln(err)
	}

	// This 8 bytes header is what we will discard
	// when downloading the file
	// TODO: Add gzip compression as default
	fmt.Fprintf(p, "GIF89a;\n")
	p.Write(Chunk)
	w.Close()
	
	if req, err = http.NewRequest("POST", uri, b); err != nil {
			log.Fatalln(err)
	}
	req.Header.Add("Content-Type", w.FormDataContentType())

	if r, err = client.Do(req); err != nil {
		log.Fatalln(err)
	}
	defer r.Body.Close()

	if _, err = io.Copy(b, r.Body); err != nil {
		log.Fatalln(err)
	} 
	wait <- string(b.String())
}

func uploadFile(Path string) {
	wait := make(chan string)
	var File *os.File
	var stat os.FileInfo
	var FileContent []byte
	var Marshaled []byte
	var err error

	if File, err = os.Open(Path); err != nil {
		log.Fatalln(err)
	}
	defer File.Close()

	if stat, err = File.Stat(); err != nil {
		log.Fatalln(err)
	}

	// We'll divide the file into 512KiB chunks
	metadata := Meta{filepath.Base(Path), 1 + stat.Size()>>19}

	bar := pb.ProgressBarTemplate(barTemplate).Start64(metadata.Chunks + 1)
	bar.Set("statement", fmt.Sprintf("uploading %s", metadata.Name))

	if Marshaled, err = json.Marshal(&metadata); err != nil {
		log.Fatalln(err)
	}
	if FileContent, err = ioutil.ReadAll(File); err != nil {
		log.Fatalln(err)
	}

	go uploadChunk(Marshaled, -1, bar, wait)

	var i int64
	for ;i < metadata.Chunks - 1; i += threads {

		for j:=int64(0); j<threads; j++ {
			go uploadChunk(
				FileContent[(i+j)<<19:(i+j+1)<<19],
				i+j, bar, wait,
				)
		}

		for j:=int64(0); j<threads ; j++ {
			if !strings.Contains(<-wait, ".gif") {
				log.Fatalln("Endpoint returned negative response")
			}
		}
	}
	go uploadChunk(FileContent[i<<19:], i, bar, wait)
	if !strings.Contains(<-wait, ".gif") {
		log.Fatalln("Endpoint returned negative response")
	}
	bar.Finish()
}

func main() {
	get := flag.Bool("get", false, "Retrieve file by supplying key")
	flag.Parse()
	args := flag.Args()
	if len(args) != 1 {
		log.Fatalln("A filepath or a key (for retrieval) must be supplied")
	}
	if *get {
		key := args[0]
		branch := fmt.Sprintf("%s%s%s/", endpoint, handle, key)
		r, err := http.Get(fmt.Sprintf("%s%s.gif", branch, key))
		if err != nil {
			log.Fatalln(err)
		}
		defer r.Body.Close()
		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			log.Fatalln(err)
		}
		metadata := &Meta{}
		if err := json.Unmarshal(body[8:], metadata); err != nil {
			log.Fatalln("Found invalid JSON for metadata. Check the supplied key and retry.")
		}
		bar := pb.ProgressBarTemplate(barTemplate).Start64(metadata.Chunks)
		bar.Set("statement", fmt.Sprintf("downloading %s", metadata.Name))
		OutFile, _ := os.Create(metadata.Name)
		defer OutFile.Close()
		var i int64
		for ; i < metadata.Chunks; i++ {
			r, err := http.Get(fmt.Sprintf("%s%s_%d.gif", branch, key, i))
			if err != nil {
				log.Fatalln(err)
			}
			defer r.Body.Close()
			io.CopyN(io.Discard, r.Body, 8)
			io.Copy(OutFile, r.Body)
			bar.Increment()
		}
		bar.Finish()
	} else {
		rand.Seed(time.Now().UnixNano())
		var alphabet = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_")
		s := make([]rune, 16)
		for i := range s {
			s[i] = alphabet[rand.Intn(64)]
		}
		key = string(s)
		branch := fmt.Sprintf("%s%s", endpoint, connector)
		http.Get(fmt.Sprintf("%s%s%s", branch, newFolder, key))
		uri = fmt.Sprintf("%s%s%s", branch, key, upload)
		uploadFile(args[0])
		fmt.Printf("Key: %s\n", key)
	}
}
